# Інструкції для AI агентів: Домашнє завдання GoIT Math 03

## Огляд проєкту
Це проєкт домашнього завдання з математичного моделювання (ДЗ-03), який реалізує методи чисельного аналізу та розв'язання диференціальних рівнянь за допомогою бібліотек наукових обчислень Python. Проєкт складається з двох незалежних завдань, що демонструють різні математичні техніки.

## Структура проєкту
- `hw03.ipynb`: Jupyter-ноутбук з теоретичними поясненнями та виконуваними комірками коду для обох завдань
- `task1.py`: Самостійний скрипт для Завдання 1 (аналіз похідних)
- `task2.py`: Самостійний скрипт для Завдання 2 (розв'язувач ДР)

## Основні залежності
- `numpy`: Фундамент для чисельних обчислень
- `scipy.optimize.approx_fprime`: Чисельне диференціювання (Завдання 1)
- `scipy.integrate.solve_ivp`: Розв'язувач задач Коші для ДР (Завдання 2)

Встановлення: `pip install numpy scipy`

## Патерни для конкретних завдань

### Завдання 1: Аналіз активності користувачів через чисельне диференціювання
**Файл**: [task1.py](task1.py), комірки ноутбука

**Мета**: Порівняти чисельні та аналітичні похідні функції навантаження `f(t) = 1000·t·e^(-0.2t)`

**Ключові патерни**:
- Функції з масивними входами для сумісності з scipy: `f_load(x)` приймає масив, витягує `t = x[0]`
- `approx_fprime(np.array([t]), f_load, epsilon)[0]` повертає масив градієнтів, беремо перший елемент
- Вибір epsilon: `np.sqrt(np.finfo(float).eps)` для оптимального чисельного кроку
- Інтерпретація часу: `t=0` відповідає 08:00, `t=2` — 10:00 тощо

### Завдання 2: Аналіз кривої навчання через ДР
**Файл**: [task2.py](task2.py)

**Мета**: Розв'язати ДР `dK/dt = r(M-K)` та знайти, коли знання досягнуть 90% від максимуму

**Ключові патерни**:
- Детекція подій у `solve_ivp`: визначити `hit_90(t, K)` з атрибутами `.terminal = True` та `.direction = 1`
- Доступ до часу події: `sol.t_events[0][0]` (перша подія, перше спрацювання)
- Обробка відсутності подій: перевірити `sol.t_events[0].size == 0` перед доступом
- Константи: `M=100` (максимум знань), `r=0.15` (швидкість навчання), `TARGET=90`
- Безпечний діапазон часу: `(0, 30)` днів забезпечує збіжність розв'язку

## Конвенції коду
- **Мова**: Коментарі та docstring українською мовою
- **Форматування**: Табличний вивід з користувацькою шириною колонок та вирівнюванням (див. `task2.py` рядки 28-42)
- **Обробка помилок**: Повертати `None` для відсутніх розв'язків, виводити "—" у таблицях
- **Чисельна точність**: Виводити 4 знаки після коми (`.4f`) для наукових результатів
- **Позначення різниці**: `Δt = t90(K0) - t90(5)` показує відносні зміни від базової лінії

## Виконання
Кожен скрипт є самодостатнім і виводить результати в stdout:
```bash
python task1.py  # Виводить таблицю порівняння похідних
python task2.py  # Виводить таблицю часу до досягнення цілі
```

Комірки ноутбука можна виконувати незалежно, але вони спільно використовують стан ядра.

## Математичний контекст
- Завдання 1 досліджує диференціювання за правилом добутку та час пікового навантаження
- Завдання 2 моделює експоненціальне зростання/спад з логістичною насиченістю
- Обидва завдання валідують чисельні методи порівняно з відомими аналітичними розв'язками або очікуваною поведінкою
